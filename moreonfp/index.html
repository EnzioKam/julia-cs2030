<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/julia-cs2030/libs/highlight/github.min.css"> <link rel=stylesheet  href="/julia-cs2030/css/jtd.css"> <link rel=icon  href="/julia-cs2030/assets/favicon.ico"> <title>More on FP</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/julia-cs2030/" class=title > Julia for CS2030 </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item {{ispage Home/*}}active{{end}}"><a href="/julia-cs2030/" class="menu-list-link {{ispage Home}}active{{end}}"> Home</a> <li class="menu-list-item {{ispage Immutability/*}}active{{end}}"><a href="/julia-cs2030/immutability/" class="menu-list-link {{ispage Immutability}}active{{end}}"> Immutability</a> <li class="menu-list-item {{ispage Functions/*}}active{{end}}"><a href="/julia-cs2030/functions/" class="menu-list-link {{ispage Functions}}active{{end}}"> Functions</a> <li class="menu-list-item {{ispage More on FP/*}}active{{end}}"><a href="/julia-cs2030/moreonfp/" class="menu-list-link {{ispage More on FP}}active{{end}}"> More on FP</a> <li class="menu-list-item {{ispage Lazy Evaluation/*}}active{{end}}"><a href="/julia-cs2030/lazyevaluation/" class="menu-list-link {{ispage Lazy Evaluation}}active{{end}}"> Lazy Evaluation</a> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="https://github.com/tlienart/Franklin.jl">Franklin on GitHub</a> </div> <div class=franklin-content ><h1 id=more_on_fp ><a href="#more_on_fp" class=header-anchor >More on FP</a></h1> <div class=franklin-toc ><ol><li><a href="#function_currying">Function Currying</a><li><a href="#piping_in_julia">Piping in Julia</a><li><a href="#closures_in_julia">Closures in Julia</a><li><a href="#some_other_interesting_things_in_julia">Some other interesting things in Julia</a></ol></div> <h2 id=function_currying ><a href="#function_currying" class=header-anchor >Function Currying</a></h2> <p>A function &#40;per the mathematical definition&#41; typically takes in only one value and returns one value. However, we often have to write functions that take in multiple parameters. One way this can be done, is by building these functions that take in multiple parameters using functions take take in single parameters. In other words, we will build a <em>n</em>-ary function using a sequence of <em>n</em> unary functions. This technique is known as <em>currying</em>, and the unary functions are known as a sequence of <em>curried</em> functions.</p> <pre><code class=language-julia >add &#61; &#40;x, y&#41; -&gt; x &#43; y
# Alternatively
new_add &#61; x -&gt; y -&gt; x &#43; y</code></pre> <p>In the above example, we rewrote the function <code>add</code> which was a function that takes in two parameters <code>x</code> and <code>y</code>, into a function <code>new_add</code> that takes in a single parameter <code>x</code> and returns another function. To call them, we would do:</p> <pre><code class=language-julia-repl >julia&gt; add&#40;1, 3&#41;
4

julia&gt; new_add&#40;1&#41;&#40;3&#41;
4</code></pre> <p>Again, this is possible since functions in julia are first-class objects, as we have seen in the <a href="../functions">previous section</a>.</p> <p>Currying allows us to partially apply our functions since we only accept one parameter at a time, and is useful when we may not have all the parameters required for complete evaluation. It also allows for greater reuse of code, if the same parameters are used for different evaluations. In the example above, I can define <code>f &#61; new_add&#40;1&#41;</code>, which is a function I can call which will add the value of 1 and any subsequent parameter I provide.</p> <p>However, unlike actual FP languages like Haskell where all functions are considered curried by default, in Julia we need to explicitly define functions that are meant to be curried like in the example above. I cannot just call <code>add&#40;1&#41;</code> or <code>add&#40;1&#41;&#40;2&#41;</code> and expect it to work.</p> <h2 id=piping_in_julia ><a href="#piping_in_julia" class=header-anchor >Piping in Julia</a></h2> <p>Julia provides the <code>|&gt;</code> or <em>pipe</em> operator, which allows functions to be combined by chaining them together sequentially. The Julia documentation <a href="https://docs.julialang.org/en/v1/manual/functions/#Function-composition-and-piping">here</a> shows a simple example of this:</p> <pre><code class=language-julia >julia&gt; 1:10 |&gt; sum |&gt; sqrt
7.416198487095663</code></pre> <p>In the example above, we take a <code>UnitRange</code> representing the numbers 1 to 10, apply the function <code>sum</code> to obtain the sum of the numbers, and apply <code>sqrt</code> on that result to obtain it&#39;s square root. What we are doing is we are applying a function, the the output of the previous function. This is similar to how you would compose a function using âˆ˜ or <code>ComposedFunction</code>. In fact, you can broadcast the operations using Julia&#39;s dot syntax.<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> <pre><code class=language-julia >julia&gt; 1:10 .|&gt; sqrt |&gt; sum
22.4682781862041</code></pre> <p>Now instead of take the square root of the sum from 1 to 10, we are taking the sum of the square roots of 1 to 10.</p> <p>The limitation of the <code>|&gt;</code> operator is that it does not work with functions that take in multiple arguments, which prevents us from doing partial application of functions. There are some packages that try to introduce this functionality such as <a href="https://github.com/oxinabox/Pipe.jl">Pipe.jl</a> and <a href="https://github.com/MikeInnes/Lazy.jl">Lazy.jl</a>.</p> <h2 id=closures_in_julia ><a href="#closures_in_julia" class=header-anchor >Closures in Julia</a></h2> <pre><code class=language-julia >function f&#40;x&#41;
    g &#61; y -&gt; x &#43; y
    return g
end

c &#61; f&#40;1&#41;</code></pre> <p>The function <code>f</code> in the example above returns another function <code>g</code>. However, notice that the function <code>g</code> actually uses the variable <code>x</code>, which is outside the scope of <code>g</code>. The variable <code>x</code> is captured by <code>g</code>. We can see this for <code>c</code>, which is a function which has a non-local variable <code>x</code> bound to the value 1. We call <code>c</code> a closure. In Julia, a closure is a callable object<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup>, usually a function, with field names corresponding to captured variables.</p> <p>Closures allow us to store information about the environment where the closure is defined, and use them later. This increases the amount of code re-use, and can allow us to represent the state of the environment. In the example below, we use the function <code>save_state</code> to create a closure that allows us to save the value of the global variable <code>state</code> at different points of the program. </p> <pre><code class=language-julia >state &#61; 0

function save_state&#40;&#41;
    x &#61; state
    return &#40;&#41; -&gt; x
end
a &#61; save_state&#40;&#41;;
state &#61; 5;
b &#61; save_state&#40;&#41;;
state &#61; 7;
c &#61; save_state&#40;&#41;;</code></pre> <p>And we can see that the values of calling <code>a</code>, <code>b</code> and <code>c</code> correspond to the value of <code>state</code> when it was created:</p> <pre><code class=language-julia-repl >julia&gt; a&#40;&#41;
0
julia&gt; b&#40;&#41;
5
julia&gt; c&#40;&#41;
7</code></pre> <p>In fact, we can implement OOP like functionality in Julia<sup id="fnref:3"><a href="#fndef:3" class=fnref >[3]</a></sup>, at the cost of referential transparency:</p> <pre><code class=language-julia >function Dog&#40;name, weight&#41;
    get_name &#61; &#40;&#41; -&gt; name
    get_weight &#61; &#40;&#41; -&gt; weight
    eat_food &#61; x -&gt; weight &#43;&#61; x
    return &#40;&#41; -&gt; &#40;get_name, get_weight, eat_food&#41;
end</code></pre> <p>Here the function <code>get_weight</code> mutates the <code>weight</code> variable, so the function <code>eat_food</code> is not a pure function.</p> <pre><code class=language-julia-repl >julia&gt; dog &#61; Dog&#40;&quot;Johnny&quot;, 20&#41;;
julia&gt; dog.get_name&#40;&#41;
&quot;Johnny&quot;
julia&gt; dog.get_weight&#40;&#41;
20
julia&gt; dog.eat_food&#40;1&#41;
21
julia&gt; dog.get_weight&#40;&#41;
21</code></pre> <h2 id=some_other_interesting_things_in_julia ><a href="#some_other_interesting_things_in_julia" class=header-anchor >Some other interesting things in Julia</a></h2> <p>In Julia, operators such as <code>&#43;</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;</code>, <code>&#61;&#61;</code> &#40;and many others&#41; are functions. For example, to sum two numbers we could just do <code>&#43;&#40;1, 2&#41;</code> instead of <code>1 &#43; 2</code>. Several operators such as <code>&#43;</code> and <code>*</code> can even accept multiple arguments: <code>*&#40;3, 4, 5&#41;</code> is a valid statement.</p> <p>Comparison operators such as <code>&lt;</code>, <code>&lt;&#61;</code>, <code>&gt;</code>, <code>&gt;&#61;</code>, <code>&#61;&#61;</code> and <code>&#61;&#61;&#61;</code> can be partially applied, by first supplying it with the &quot;left&quot; side of the operation.</p> <pre><code class=language-julia-repl >julia&gt; eq_5 &#61; &#61;&#61;&#40;5&#41;;
julia&gt; eq_5&#40;1&#41;
false
julia&gt; eq_5&#40;5&#41;
true

julia&gt; lt_8 &#61; &lt;&#40;8&#41;;
julia&gt; lt_8&#40;2&#41;
true
julia&gt; lt_8&#40;9&#41;
false</code></pre> <p><table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content >The dot syntax in Julia makes use of broadcasting to allow us to easily create vectorised functions from unary functions, without the need to have a separate implementation. </table> <table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >Julia has function-like objects, allowing instances of composite types to be called like functions by adding methods to the type itself. &#40;Not be confused with functors in FP.&#41; </table> <table class=fndef  id="fndef:3"> <tr> <td class=fndef-backref ><a href="#fnref:3">[3]</a> <td class=fndef-content >The use of closures may affect performance of captured variables. See <a href="https://github.com/JuliaLang/julia/issues/15276">here</a>. </table> </p> <div class=page-foot > <div class=copyright > Last modified: August 12, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap--> <script src="/julia-cs2030/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>